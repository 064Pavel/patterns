## [Strategy](https://refactoring.guru/ru/design-patterns/strategy)

Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

## Какую проблему решает

Паттерн Стратегия предоставляет решение для ситуаций, когда необходимо выбирать из различных алгоритмов выполнения задачи в зависимости от контекста или требований во время выполнения программы. Вместо того чтобы жестко привязываться к одному алгоритму во время компиляции, этот паттерн позволяет динамически выбирать подходящий алгоритм в процессе выполнения.

Например, он может использоваться для выбора разных методов сортировки в зависимости от типа данных или объема, для применения различных стратегий сжатия данных в зависимости от формата, или для применения различных стратегий валидации веб-форм в зависимости от требований пользователей.

Такой подход делает код более гибким и расширяемым, позволяя легко добавлять новые алгоритмы без изменения существующего кода, а также избегать дублирования кода за счет выделения общих поведенческих элементов в отдельные стратегии.

## Решение

Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.

Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.

Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.

## Применимость

1. Когда у вас есть несколько вариантов алгоритмов, которые могут быть применены к задаче, и вы хотите, чтобы они были легко заменяемы во время выполнения программы.
2. Когда у вас есть множество похожих классов, которые отличаются только их поведением. Вместо создания подклассов для каждого варианта поведения можно использовать паттерн Стратегия, чтобы изолировать их в отдельные стратегии.
3. Когда вы хотите избежать дублирования кода, связанного с различными вариантами алгоритмов, и предпочитаете выделить его в отдельные классы.
4. Когда у вас есть сложное условное поведение внутри класса, и вы хотите избежать переполненности методов условными операторами, делегируя каждую ветвь условия в отдельную стратегию.

## Шаги реализации

1. Определение интерфейса стратегии: Создайте интерфейс или абстрактный класс, который определяет общий метод или набор методов, которые будут реализованы всеми конкретными стратегиями. Этот интерфейс определяет контракт, который каждая стратегия должна соблюдать.
2. Создание конкретных стратегий: Для каждого алгоритма или варианта поведения создайте конкретный класс, реализующий интерфейс стратегии. Каждая стратегия должна реализовать методы, определенные в интерфейсе, в соответствии с ее уникальным алгоритмом.
3. Использование контекста: Создайте класс контекста, который содержит ссылку на интерфейс стратегии. Этот класс предоставляет методы, которые клиентский код может вызывать для выполнения алгоритма. Внутри этих методов контекст делегирует выполнение соответствующей стратегии.
4. Настройка стратегии: В момент создания объекта контекста или во время его работы установите соответствующую стратегию. Это может быть сделано через конструктор, сеттер или другой метод, который позволяет динамически менять стратегию во время выполнения программы.
5. Вызов стратегии: Клиентский код вызывает методы контекста для выполнения алгоритма. Контекст, в свою очередь, делегирует выполнение соответствующей стратегии, изолируя клиентский код от деталей реализации конкретных алгоритмов.

## Приемущества

* Замена алгоритмов на лету
* Изолирует код и данные алгоритмов от остальных классов
* Уход от наследования к делегированию
* Реализует принцип открытости/закрытости

## Недостатки

* Усложняет программу за счёт дополнительных классов
* Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую